# ToyOS
- 以下为各部分的概述并且均基于x86
### 启动及引导
首先需要了解计算机从开机到运行操作系统之间发生了什么。
1. 读取ROM,运行其中的程序bios(basic input/output system),它会进行硬件自检,目的是检测硬件是否有问题,若没有问题,进行下一步
2. 接着bios需要将运行权转移给下一阶段的启动程序,bios给存储设备设定有启动顺序,我们可以通过进入bios操作界面来改变它。bios将运行权移交给排在启动顺序最前面的设备
3. 此时计算机读取主引导记录(Master boot record,简记为MBR),即该设备的第一个扇区(前512字节),若该扇区的最后两个字节为0x55和0xAA,证明该设备可以用于启动;否则证明该设备不能用于启动,控制权交给启动顺序的下一个设备。
4. 接着使用设备启动,此时一般会运行启动管理器(boot loader),linux下的是grub,通过启动管理器,可以选择启动哪个操作系统,然后将运行权交给操作系统
5. 操作系统的内核被载入内存,开始运行

由于该项目采用grub来引导,以及使用软盘镜像,因此第2、3、4步都不用花费太大的精力。不过由于使用了grub需要遵守其multiboot标准,因此需要了解一下。除此之外,我们还需要在内核中加入multiboot头,它所处的位置也有要求,一般将在放在最开头。multiboot头必须包含magic、flag以及checksum几个域,通过flag置不同的位,可以使用不同的功能,我们只需要其对齐还有获取内存信息这两个即可。可以参考该[博客](http://www.cnblogs.com/chio/archive/2008/01/01/1022430.html)了解一下。
关于软盘镜像的制作,本来使用dd命令就可以创建一个软盘镜像,但是由于我们要使用grub,因此需要将grub也加入到软盘镜像中。具体的步骤可以参考该博客:[制作软盘镜像并加入grub引导](http://blog.csdn.net/RichardGreenhhh/article/details/78087066)。这里我们直接使用现成的`floppy.img`即可。

### 屏幕输出
该部分需要了解显卡的工作模式(文本模式和图形模式)中的文本模式,在4G的地址空间中,并不是所有的空间都给了内存,而是1M以下的分给了外设,其中显存就会占据一定的空间。一般`0xB8000-0xBFFFF`这段物理地址(彩色模式)被映射到显存,也就是说写这些物理地址,就可以控制显示内容,每两个字节表示屏幕上显示的一个字符,前一个是显示字符的ascll码,后一个控制显示字符的颜色等,关于其编码,这里就不列出了,网上有很多资料。标准的屏幕有25行,80列,关于屏幕的换行以及清空都需要我们自己来实现。

除此之外,我们还需要显示光标,在VGA显卡内有很多寄存器来控制显卡的状态,而在pc上,`0x3d4`和`0x3d5`两个端口用来读写显卡的内部寄存器,存放光标位置的寄存器编号为14和15。因此我们设置光标的方法即先向`0x3d4`端口写入要访问的寄存器编号,再通过`0x3d5`端口来读写寄存器数据,两个寄存器合起来组成一个16位整数,这个整数就是光标的位置。至于怎么写,我们通过`inb`、`outb`等指令即可。

### 调试相关
为了方便我们直观的看到一些功能的结果以及出问题时调试,需要实现`printk`函数。这里面就涉及到了可变参的获取。在调用函数时,参数一般是从右往左入栈(64位下会使用寄存器传参,这里我们不考虑),关于可变参函数,我们可以获取到第一个参数的地址,之后便可以利用栈这种结构以及下一个参数的类型来获取到其他参数的地址,从而进行访问,这样就实现了可变参。
在`printf`库函数的实现中,就利用了`va_list`变量、`va_start`宏函数、`va_arg`宏函数、`va_end`宏函数来实现。
在x86平台下,`va_list`变量定义为`char *`,而宏函数大致实现如下:
```
#define va_start(ap,v) ( ap = (va_list)&v + _INTSIZEOF(v) )          //第一个可选参数地址
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )  //下一个参数地址
#define va_end(ap)   ( ap = (va_list)0 )                           // 将指针置为无效
```
关于`_INTSIZEOF`宏,是用位运算实现的,作用是获取变量占用的空间大小(对齐后)。`va_start`和`va_end`都比较容易理解。而`va_arg`,它传入当前参数的地址和下一个参数的数据类型,它的作用有两个,一个是返回当前参数地址,另一个是将ap指向下一个参数,因此有加了又减这样的操作。

知道了这些,其实离实现`printk`还有一定的距离,因为还要控制`%d`、`%c`等占位符,代码中直接利用了linux早期的`printk`函数的实现。

除了`printk`,我们还可以获取到当前函数调用栈来帮助我们调试。如何获取函数名以及获取到调用了哪些函数,这是两个主要的问题。
关于函数名的获取,我们可以通过获取到`multiboot_t`结构体中存储elf文件中section信息的变量,再从中得到符号表以及字符串表,通过判断函数的地址是否在符号表中某个符号的区间中,我们就可以从字符串表中获取到该符号的名字。

那么问题就变成了如何获取函数地址。在我们调用函数时,在汇编层面,首先会将esp寄存器的值入栈,然后将esp的值赋给ebp,从而形成新的函数栈。因此,我们可以通过获取到ebp寄存器的值,该值就是函数的地址了。

### 分段
这部分我们需要设置gdt(global descriptor table),全局描述符表。它存放了各段的一些信息,例如段基址以及其权限等。该表可以放置在内存中的任何位置上,通过gdtr寄存器(存放gdt的基地址及边界)就可以获取到gdt的基址。如何通过gdt准确访问到我们想要访问的段,这是通过段寄存器(段选择子)来实现的,在实模式下,段寄存器直接存放段的基址(实模式只有1MB的寻址空间),在保护模式下,段寄存器存放段在gdt的索引信息。(通过设置cr0寄存器的PE位即可从实模式进入到保护模式)

因此我们通过段寄存器存储的索引信息加上偏移形成的地址,就可以访问到段中的任何一个字节了,这种地址称为逻辑地址,而段基址加上偏移形成的地址称为线性地址,若没有开启分页机制,则线性地址就是物理地址;开启了分页还要进行进一步的转换才能得到物理地址。

最后,关于段描述符,需要去查阅intel文档,才能设置每个段的权限等信息。
### 中断
关于中断,和gdt类似,需要设置idt(interrupt descriptor table)存放在主存中,通过idtr寄存器获取到其基址。关于中断的处理过程,这里需要简单的说一下:
1. cpu在执行每条指令时,会检查是否有中断请求,如果有,获取到中断向量(idt中的索引)
2. 根据中断向量获取中断描述符,再从描述符中存储的中断处理函数段选择子获取到中断处理函数的地址
3. 保存现场,因为当前cpu可能正在执行程序,所以需要将寄存器的值保存起来,以便中断处理之后恢复执行
4. 根据中断处理函数的地址,执行中断处理函数
过程大概就是这样,简化了很多细节。intel处理器支持0-255个中断,而0-31都是cpu占用的,32-255供用户自己使用。0-19号都有实际的意义,而20-31号被保留下来,供以后扩展。通过给中断号注册中断处理函数,就可以实现中断的处理了,不过保护以及恢复现场需要特别注意。

关于时钟中断,首先给其注册中断处理函数,再设置好频率即可。
#### 管理物理内存
通过multiboot_t结构体中的`mmap_length`和`mm_addr`可以获取到内存的地址及大小,grub将内存探测的结果按每个分段整理为`mmap_entry`结构体数组。`mmap_addr`是这个结构体数组的首地址,`mmap_length`是整个数组的长度。

通过遍历`mmap_entry`数组,我们就可以获取到内存信息。接下来将物理内存分成大小为4KB的页框(为了实现虚拟内存),并且为了更好的管理物理内存,使用了简化版的伙伴系统来管理(以页为单位),减少外部碎片的产生。
#### 管理虚拟内存
在虚拟地址空间中,内核是处于3G-4G地址中的,这里只是简单的将物理地址加上`0xc0000000`完成映射。但是有个问题,grub是从1MB处加载内核,在链接时以`0xc0100000`为基址进行重定位,但一开始并没有进行虚存的映射,所以会出错。解决方法就是设置一个临时的入口函数,然后建立好物理内存和虚拟内存之间的映射关系,将临时的页目录地址设置给cr3寄存器并设置cr0寄存器的分页标志位开启分页,然后再跳到之前的入口函数即可。

开启分页后,之前得到的线性地址就不再等同于物理地址了,假设是两级页表,就需要根据地址中页目录地址以及页表来得到物理地址。
### 管理堆空间
这一步主要实现`kmalloc`函数。项目中实现时,首先预先分配512个页供其使用。并且限制最小分配单位,防止大量外部碎片产生。维护一个链表,当需要分配空间时,将块分割即可,然后形成新的结点,接在链表上。当内存释放时,将该块内存与前一个或者后一个结点合并即可。
### 实现内核进程
首先需要一个结构体来记录进程的信息,即pcb。其中存放了进程号、进程状态、地址空间、上下文等信息。关于进程间的切换,就代表需要切换进程上下文,即保存与恢复寄存器的值。另外关于进程的调度,项目中并没有用到复杂的调度算法,而是简单的使用链表进行组织,并且在可调度进程链表中选择一个进程来运行。

