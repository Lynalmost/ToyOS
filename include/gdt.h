/*************************************************************************
    > File Name: gdt.h
    > Author: Ukey
    > Mail: gsl110809@gmail.com
    > Created Time: 2017年04月14日 星期五 09时11分01秒
 ************************************************************************/

/*
 * 首先简单的介绍一下实模式和保护模式,在实模式工作下的PC的寻址能力很有限,物理地址=段值x16+偏移,并且段值和偏移都是16位
 * 的。并且实模式的数据总线只有16位,也就是一次最多能传输的数据只有2^16=64KB,这就是为什么每个段最大只有64KB,并且它的地址
 * 总线为20位,因此能够寻址的能力是2^20=1MB,既然有了1MB的寻址能力,但是一次只能读取64KB的数据,所以才引入了分段机制。实模式
 * 有个重要的特性,那就是可以访问任意地址而不受限制。
 * 而在保护模式下,寻址的能力得到了很大的提升以及。段值虽然还是16位,但是意义发生了改变,变成了一个索引,指向了一个数据结构
 * 的表项,表项中存着段的起始地址、界限和属性等信息,这个表被称为GDT(全局描述符表),表项被称为描述符,存放在内存中。
 * 描述符分为三种：数据段描述符、指令段描述符和系统段描述符
 * 
 * 因为存放的位置并不固定,所以需要拿一个专门的48位的寄存器GDTR来存放GDT的基址和边界位置。0-15位存全局描述符表边界,16-47
 * 位存放全局描述符表基地址。
 * 那么我们怎么访问具体的哪个段呢？通过段选择子(其实相当于实模式下的段寄存器)就可以实现了,里面保存了索引的值和是全局描述符还是局部描述符以及特权级。
 * 
 * 总之,保护模式下的寻址和实模式下类似,只是保护模式下的通过段选择子指向了GDT中的描述符,通过描述符定位到相应的段,再通过
 * 偏移,转换成线性地址,如果没有分页机制,那么该线性地址就是真正的物理地址。
 * 
 * 还有一点是如何从实模式转换到保护模式,只用将控制寄存器之一的cr0的PE位置1就从实模式转换到保护模式了。需要进行以下步骤
 * 1.初始化准备好GDT
 * 2.把gdt的物理地址加载到寄存器gdtr中
 * 3.关闭中断,这是因为保护模式和实模式的中断处理机制不同,而我们还没有写中断处理机制
 * 4.接着将寄存器cr0的PE置1
 * 5.最后跳转到保护模式
 * 
 * 大致就是这些步骤,接下来就进行细化工作吧。如果还不理解，可以参考我的博客：http://blog.csdn.net/move_now/article/details/56478468。和http://blog.csdn.net/move_now/article/details/56895132。里面由相应的图解。
 * 
 */

#ifndef INCLUDE_GDT_H_
#define INCLUDE_GDT_H_


#include "types.h"


//全局段描述符结构
typedef struct gdt_entry_t
{
	uint16_t limit_low;		//段的界限,还有3位的高地址部分存在另外的字段中
	uint16_t base_low;		//段的基地址,一共占了4个字节。在地址中分了两个部分,一个三字节的,一个一字节的。但是由于没有3字节的数据类型,只有分成三个部分了。这是最低的那2个字节
	uint8_t base_middle;	//这是中间的那一个字节
	uint8_t access;		//接下来就是属性等方面的了。有描述符的类型、以及是数据段/代码段还是系统段/门描述符、描述符特权级、是否在内存中存在这些信息
	uint8_t granularity;	//余下的部分,有3位的段界限、AVL保留位等信息(有些比较复杂,不能展开讨论,感兴趣的可以查一下)
	uint8_t base_high;		//段基地址
}__attribute__((packed)) gdt_entry_t;

//GDTR	有48位,低16位存储全局描述符表的边界,高48位存储全局描述符表的基地址
typedef struct gdt_ptr_t
{
	uint16_t limit;		//低16位
	uint32_t base;		//高32位
}__attribute__((packed)) gdt_ptr_t;

//初始化全局描述符表
void init_gdt();

//GDT加载到GDTR的函数
extern void gdt_flush(uint32_t );

#endif

